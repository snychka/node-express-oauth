## 1. Building the Authorization Server

1. **Creating the authorization route** - In `authorization-server.js` create a new empty server route that accepts `GET` requests to the `/authorize` endpoint using the `app.get` method. The empty route should return a `200` status by default, using the `res.end()` method.
2. **Verifying the client ID** - Next, get the `client_id` param from the `req.query` object and verify if the client ID exists by checking the `clients` object in the same file. If the client ID does not exist, respond with a `401` status code using the `res.status` method. If the client ID exists, return a `200` status.
3. **Validating the scopes requested** - After the client ID is validated, we need to ensure that the requested scopes are a subset of the allowed scopes for the client. For example, the client with ID `"my-client"` is allowed to request for the `"permission:name"`, and the `"permission:date_of_birth"` scopes. The requested scopes are available in the `req.query.scopes` parameter as a space separated string. We can split this string into it's individual scopes by using the `req.query.scope.split(" ")` method. You can use the `containsAll(arg1, arg2)` function imported from the `utils.js` file to check if the array `arg1` contains all the elements of the array `arg2`. If requested scopes are not a subset of the allowed scopes, return a `401` status code.
4. **Storing the request** - Now that we have verified all the client credentials and scope, we need to create a request ID and temporarily store the request object to use in the next section. You can see an empty `requests` object already declared in the file. We need to create a random string as the request ID, which will be a key stored in the `requests` object, with the value being the `req.query` object. To help you generate a random string, you can use the `randomString()` function in the `utils.js` file.
5. **Rendering the login page** - We now need to render the login page for the user to login to our system. You can render the login page using the `res.render(page, params)`. The `page` argument can be set to `"login"` which will render the `assets/authorization-server/login.ejs` template file. The `params` argument is needed to supply parameters to the template file. In this case `params` needs to be an object with three keys: `"client"`, whose value will be the client ID; `"scope"`, whose value would be set to the value of `req.query.scope`; `"requestId"` whose value would be set to the value of the random request ID string generated in the previous task.
6. **Creating the approve route** - Once the user goes to the login page rendered in the last step, they will be shown a login form which will send a request to the approval endpoint. Create a new server route that accepts `POST` requests to the `/approve` endpoint using the `app.post()` method.
7. **Verifying the username and password** - The `POST` request contains the `userName`, `password` and `requestID` keys in the `req.body` object. We need to check if the `userName` and `password` match. The usernames and passwords are listed in the `users` variable near the beginning of the file, with the usernames as keys and the passwords as values (for example `john` is a username with `appleseed` as their password). If the usernames and passwords don't match, return a `401` status.
8. **Checking if the request exists** - We now have to check if the request with the given `requestId` (that was provided in `req.body`) actually exists. We can do this by checking if a key corresponding to `requestId` exists in the `requests` object (using `requests[requestId]`). If it doesn't exist, return a `401` status. If it does exist, assign it to a local variable (for use in the next task) and delete it from the `requests` object.
9. **Storing the request and userName** - Next we need to retain the client request we obtained from the previous task (the value stored in `requests[requestId]`), and the `userName` of the logged in user in the `authorizationCodes` local variable. `authorizationCodes` is an empty object declared near the start of the file. Generate a random string (with the `randomString()` function) and set it as a new key in `authorizationCodes`, with the value being an object with two attributes: `"clientReq"`, whose value is the client request object, and `"userName"`, whose value is the `userName` of the logged in user. This random string will be the "code" which we will use in the next task.
10. **Redirecting the user** - The client request object will contain a `redirectUri`, and a `state` attribute. We need to send a redirect response to this redirect URI using the `res.redirect()` method of the express.js response object. We also need to add the code generated in the last step and the state as query params to the redirect URI. For example, if the `redirectUri` value is `http://www.example.com/go-here`, our code is `"rof5ijf"`, and the state is `"pc03ns9S"`, we need to redirect to `http://www.example.com/go-here?code=rof5ijf&state=pc03ns9S`
11. **Creating the token route** - Now that we can issue an authorization code to the client redirect URI, we need to create a `/token` route to issue the authorization token using the authorization code. Create a new server route that accepts `POST` requests to the `/token` endpoint using the `app.post()` method.
12. **Checking if authorization credentials exist** - We expect this endpoint to receive an authorization token in the `req.headers.authorization` attribute. Check if the `authorization` header exists. If not, return a `401` status.
13. **Verifying the authorization header** - Each authorization header is encoded with the standard basic auth algorithm. A helper function `decodeAuthCredentials` is present in the `utils.js` file, which accepts the auth token and returns and object containing `clientId` and `clientSecret` keys. We need to check if these match the client IDs and secrets stored with us. This can be found in the `clients` object at the start of the file. For example, `my-client` is a client ID whose client secret is `zETqHgl0d7ThysUqPnaFuLOmG1E=`. If the client ID and secret don't match, return a `401` status.
14. **Verifying the authorization code** - The `req.body` object contains the `code` key attribute, whose value corresponds to the code we issued in the last route. We need to check if an object that matches this code exists in the `authorizationCodes` object. For example, if the `req.body.code` is `"abc"`, we need to check if `obj = authorizationCodes["abc"]` exists. If it doesn't, return a `401` status. If it exists, save the value in a local variable (for later use) and delete the key from `authorizationCodes`.
15. **Issuing the access token** - Once all the above info has been validated, we need to create a signed token, and return it as the response. Create a new JWT using the `jwt.sign` method from the `"jsonwebtoken"` library (you can use other libraries if you prefer as well). The object we need to encode needs to contain the `"userName"` and `"scope"` keys, which can be obtained from the object we extracted from `authorizationCodes` in the last step (as `obj.userName` and `obj.clientReq.scope` respectively). This needs to be encoded using the `"RS256"` algorithm. The public and private keys for this can be found in the `assets` folder as `public_key.pem` and `private_key.pem`. Once we create the JWT string, respond with a `200` status and a JSON body with the following parameters: `"access_token"`, whose value is the JWT string; `"token_type"`, whose value is `"Bearer"`.
